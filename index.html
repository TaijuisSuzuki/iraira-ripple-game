<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8">
<title>Iraira Ripple Game</title>
<style>
  html,body{margin:0;padding:0;overflow:hidden;background:#111;color:#fff;font-family:sans-serif}
  #ui{position:fixed;top:10px;left:10px;z-index:10}
  h1{font-size:18px;margin:0 0 4px}
</style>
</head>
<body>
<canvas id="game"></canvas>
<div id="ui">
  <h1 id="status">Loading…</h1>
  <button id="retry" style="display:none">Retry</button>
</div>

<script>
//==============================//
// 1. 画像プリロード
//==============================//
const IMG_PATHS={
  player:'img/player.png',
  ishibe:'img/ishibesawa.png',
  ohya  :'img/ohyakaisei.png',
  cig   :'img/cigarette.png',
  beer  :'img/beer.png'
};
const IMAGES={};
function loadImages(map){
  return Promise.all(Object.entries(map).map(([k,src])=>new Promise((ok,ng)=>{
    const img=new Image();
    img.onload=()=>{IMAGES[k]=img;ok();}
    img.onerror=()=>{console.error('IMAGE 404:',src);ng(src);}
    img.src=src;
  })));
}

//==============================//
// 2. Canvas & 共通関数
//==============================//
const cvs=document.getElementById('game');
const ctx=cvs.getContext('2d');
function resize(){cvs.width=innerWidth;cvs.height=innerHeight;}
addEventListener('resize',resize);resize();

let mouse={x:cvs.width/2,y:cvs.height/2};
cvs.onmousemove=e=>{const r=cvs.getBoundingClientRect();
  mouse.x=e.clientX-r.left;mouse.y=e.clientY-r.top;};
cvs.ontouchmove=e=>{e.preventDefault();const r=cvs.getBoundingClientRect();
  mouse.x=e.touches[0].clientX-r.left;mouse.y=e.touches[0].clientY-r.top;},{passive:false};

const dist=(a,b)=>Math.hypot(a.x-b.x,a.y-b.y);
function drawCenter(img,x,y,r){
  const s=(r*2)/img.width;
  ctx.save();ctx.translate(x,y);ctx.scale(s,s);
  ctx.drawImage(img,-img.width/2,-img.height/2);ctx.restore();
}

//==============================//
// 3. エンティティ
//==============================//
class Player{
  constructor(){this.r=24;this.x=cvs.width/2;this.y=cvs.height/2;}
  update(){this.x=mouse.x;this.y=mouse.y;}
  draw(){drawCenter(IMAGES.player,this.x,this.y,this.r);}
}

class Ishibesawa{
  constructor(){
    this.r=20;
    this.x=Math.random()*cvs.width;
    this.y=Math.random()*cvs.height;
    this.speed=1.5;
    this.changeDir();
    this.dirTimer=0;
  }
  changeDir(){
    const ang=Math.random()*Math.PI*2;
    this.vx=Math.cos(ang)*this.speed;
    this.vy=Math.sin(ang)*this.speed;
  }
  update(dt){
    this.dirTimer+=dt;
    if(this.dirTimer>3000){this.dirTimer=0;this.changeDir();}
    this.x+=this.vx;this.y+=this.vy;

    // 端で反射
    if(this.x<this.r||this.x>cvs.width-this.r){this.vx*=-1;}
    if(this.y<this.r||this.y>cvs.height-this.r){this.vy*=-1;}
  }
  draw(){drawCenter(IMAGES.ishibe,this.x,this.y,this.r);}
}

class Ohyakaisei{
  constructor(x,y){
    this.r=24;this.x=x;this.y=y;this.speed=2.2;
  }
  update(player){
    const dx=player.x-this.x,dy=player.y-this.y,l=Math.hypot(dx,dy)||1;
    this.x+=dx/l*this.speed;this.y+=dy/l*this.speed;
  }
  draw(){drawCenter(IMAGES.ohya,this.x,this.y,this.r);}
}

// プレイヤーに追従するイライラオーラ
class Aura{
  constructor(player){
    this.p=player;
    this.r=10;this.min=10;this.max=120;
    this.speed=0.02; // 0.02px/ms ≒ 20px/秒
  }
  update(dt){
    this.r+=this.speed*dt;
    if(this.r>this.max)this.r=this.min;
    this.x=this.p.x;this.y=this.p.y;
  }
  draw(){
    ctx.save();ctx.translate(this.x,this.y);

    // 内側透明 → 外側赤
    const g=ctx.createRadialGradient(0,0,this.r*0.8,0,0,this.r);
    g.addColorStop(0,'rgba(255,0,0,0)');
    g.addColorStop(1,'rgba(255,0,0,0.5)');
    ctx.fillStyle=g;
    ctx.beginPath();ctx.arc(0,0,this.r,0,Math.PI*2);ctx.fill();

    // 境界ライン
    ctx.strokeStyle='rgba(255,0,0,0.8)';
    ctx.lineWidth=2;
    ctx.beginPath();ctx.arc(0,0,this.r,0,Math.PI*2);ctx.stroke();

    ctx.restore();
  }
}

//==============================//
// 4. ゲームステート
//==============================//
let player,aura,ishibe,ohya;
let state,timer,lastT;

function init(){
  player=new Player();
  aura=new Aura(player);
  ishibe=new Ishibesawa();
  ohya=null;
  state='PLAYING';
  timer=0;lastT=undefined;
  document.getElementById('retry').style.display='none';
  requestAnimationFrame(loop);
}

function spawnOhya(){
  const edge=Math.floor(Math.random()*4);let x,y;
  const margin=40;
  if(edge===0){x=Math.random()*cvs.width;y=-margin;}
  if(edge===1){x=cvs.width+margin;y=Math.random()*cvs.height;}
  if(edge===2){x=Math.random()*cvs.width;y=cvs.height+margin;}
  if(edge===3){x=-margin;y=Math.random()*cvs.height;}
  ohya=new Ohyakaisei(x,y);
  state='CHASE';
}

function loop(t){
  if(state!=='GAMEOVER')requestAnimationFrame(loop);
  const dt=t-(lastT??t);lastT=t;
  update(dt);draw();
}

function update(dt){
  timer+=dt;
  player.update();aura.update(dt);ishibe.update(dt);
  if(state==='CHASE')ohya.update(player);

  // Ishibesawa がオーラに触れたら Ohya 召喚
  if(!ohya && dist(ishibe,player)<aura.r+ishibe.r){
    spawnOhya();
  }

  // Ohya がプレイヤーに触れたらゲームオーバー
  if(ohya && dist(ohya,player)<ohya.r+player.r){
    state='GAMEOVER';
    document.getElementById('retry').style.display='inline';
  }
}

function draw(){
  ctx.clearRect(0,0,cvs.width,cvs.height);
  aura.draw();
  player.draw();
  ishibe.draw();
  if(ohya)ohya.draw();

  const s=document.getElementById('status');
  s.textContent=(state==='GAMEOVER'?'Final ':'Time: ')+(timer/1000).toFixed(1)+'s';
}

document.getElementById('retry').onclick=init;

//==============================//
// 5. 起動
//==============================//
loadImages(IMG_PATHS).then(()=>{
  document.getElementById('status').textContent='Time: 0.0s';
  init();
});
</script>
</body>
</html>
